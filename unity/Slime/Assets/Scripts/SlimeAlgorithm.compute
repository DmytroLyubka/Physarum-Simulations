#pragma kernel AlgorithmStep

// Agent structure to match that of the slime algorithm.
struct Agent
{
    float2 position;
    float angle;
};

RWStructuredBuffer<Agent> agents; // contains agent structures
RWTexture2D<float4> trailMap; // tracks agent positions over time
RWTexture2D<float4> staticTrailMap; // tracks static trails
uint agentCount; // number of agents in simulation
int width; // texture width
int height; // texture height
float moveSpeed; // agent move speed
float agentRotationAngle; // angle at which agents rotate
float sensorOffset; // sensor distance from agent
float sensorAngle; // sensor angle relative to agent
float time; // total time passed since start of simulation
int trailDeposit; // trail value agents deposit
bool agentCollision; // agent collision toggle
bool torus; // torus surface toggle
float staticTrailStrength; // strength of static trails

// Computes a random 32-bit uint in the range 0 to 4294967295.
uint pcgHash(uint input)
{
    uint state = input * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

// Scales random uint to the range 0 and 1.
float scale(uint input)
{
    // 4294967295 = maximum value of a 32-bit unsigned int
    return input / 4294967295.0;
}

// Evaluates N mod M, supports negative N (native % operator does not)
float mod(float n, float m)
{
    return ((n % m) + m) % m;
}

// Checks trail map value detected by a sensor with angle sensorDeltaAngle
// relative to agent.
float checkSensor(Agent agent, float sensorDeltaAngle)
{
    float globalSensorAngle = agent.angle + sensorDeltaAngle;
    float2 sensorDirection = float2(cos(globalSensorAngle), sin(globalSensorAngle));
    float2 sensorPosition = agent.position + sensorDirection * sensorOffset;

    int sensorCoordX, sensorCoordY;
    if (torus)
    {
        sensorCoordX = (int) round(mod(sensorPosition.x, width));
        sensorCoordY = (int) round(mod(sensorPosition.y, height));
    }
    else
    {
        sensorCoordX = clamp(sensorPosition.x, 0, width-1);
        sensorCoordY = clamp(sensorPosition.y, 0, height-1);
    }

    // Return equally weighted sum of RGB channels for sensor's pixel in both the dynamic and static trail maps
    return dot(trailMap[int2(sensorCoordX, sensorCoordY)].xyz, int3(1, 1, 1)) + dot(staticTrailMap[int2(sensorCoordX, sensorCoordY)].xyz, int3(1, 1, 1)) * staticTrailStrength;
}

// Executes algorithm step.
[numthreads(16,1,1)]
void AlgorithmStep (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= agentCount)
    {
        return;
    }

    Agent agent = agents[id.x];
    float2 pos = agent.position;

    uint random = pcgHash(pos.y * width + pos.x + pcgHash(id.x + time * 100000));

    // Check sensor trail values
    float frontTrailValue = checkSensor(agent, 0);
    float leftTrailValue = checkSensor(agent, sensorAngle);
    float rightTrailValue = checkSensor(agent, -sensorAngle);

    // Continue in same direction
    if (frontTrailValue > leftTrailValue && frontTrailValue > rightTrailValue)
    {
        // pass
    }
    /* Note: It doesn't really make sense to have the choice between left and right
     * rotation be random here? The fact that the front sensor is detecting a weaker
     * chemoattractant than the two off-centre sensors does not imply that the left
     * and right sensors have equal chemoattractant concentration, it is very much
     * possible that the left sensor has detected a higher trail value while at the
     * same time the front sensor has detected the lowest trail value (in which case
     * the agent should rotate left).
     * 
     * TODO: Make this step more deterministic, only have rotation choice be random if
     * left and right sensors have the same trail value, both of which must be higher
     * than that of the front sensor.
     */
    else if (frontTrailValue < leftTrailValue && frontTrailValue < rightTrailValue)
    {
        if (scale(random) > 0.5)
        {
            agents[id.x].angle += agentRotationAngle;
        }
        else
        {
            agents[id.x].angle -= agentRotationAngle;
        }
    }

    // Turn right
    else if (rightTrailValue > leftTrailValue)
    {
        agents[id.x].angle -= agentRotationAngle;
    }
    // Turn left
    else if (leftTrailValue > rightTrailValue)
    {
        agents[id.x].angle += agentRotationAngle;
    }
    else
    {
        /* All sensor trail values are equal - maybe have random choice of rotation direction
            * here?
            */
        // pass
    }

    // Update position
    float2 direction = float2(cos(agent.angle), sin(agent.angle));
    float2 newPosition = agent.position + direction * moveSpeed;

    if (torus)
    {
        newPosition.x = mod(newPosition.x, width);
        newPosition.y = mod(newPosition.y, height);
    }

    bool newPositionOccupied = false;
    // Check if new position is already occupied by an agent
    if (agentCollision)
    {
        for (uint i = 0; i < agentCount; i++)
        {
            if (all(agents[i].position == newPosition))
            {
                newPositionOccupied = true;
            }
        }
    }

    // Agent has hit boundary or target position is occupied, choose random agent angle and don't deposit trail
    if ((((newPosition.x < 0 || newPosition.x >= width || newPosition.y < 0 || newPosition.y >= height)) && !torus)
            || newPositionOccupied)
    {
        random = pcgHash(random);
        float randomAngle = scale(random) * 2 * 3.1415;

        newPosition.x = clamp(newPosition.x, 0, width-1);
        newPosition.y = clamp(newPosition.y, 0, height-1);

        agents[id.x].angle = randomAngle;
    }
    // No boundaries hit, deposit trail
    else
    {
        trailMap[int2(newPosition)] = float4(trailMap[int2(newPosition)].xyz + trailDeposit, trailMap[int2(newPosition)].w);
    }

    agents[id.x].position = newPosition;
}


#pragma kernel ProcessTrailMap

RWTexture2D<float4> processedTrailMap;
float decayRate;
float diffuseRate;
int kernelHalfWidth;

// Decays and diffuses trail map.
[numthreads(8,8,1)]
void ProcessTrailMap (uint3 id : SV_DispatchThreadID)
{
    if (id.x < 0 || id.x >= (uint)width || id.y < 0 || id.y >= (uint)height)
    {
        return;
    }

    float3 sum = 0;
    for (int x = -kernelHalfWidth; x <= kernelHalfWidth; x++)
    {
        for (int y = -kernelHalfWidth; y <= kernelHalfWidth; y++)
        {
            int kernelX = clamp(id.x + x, 0, width-1);
            int kernelY = clamp(id.y + y, 0, height-1);
            sum += trailMap[int2(kernelX, kernelY)].xyz;
        }
    }

    float3 diffusedTrail = sum / ((1 + 2 * kernelHalfWidth)*(1 + 2 * kernelHalfWidth));

    // Weighted average between original and diffused trail values
    float3 weightedDiffusedTrail = (1 - diffuseRate) * trailMap[id.xy].xyz + diffuseRate * diffusedTrail;

    processedTrailMap[id.xy] = float4(max(0, weightedDiffusedTrail - decayRate), trailMap[id.xy].w);
}

#pragma kernel RefreshStaticValues

// Sets static trail map values.
[numthreads(8,8,1)]
void RefreshStaticValues (uint3 id : SV_DispatchThreadID)
{
    if (id.x < 0 || id.x >= (uint)width || id.y < 0 || id.y >= (uint)height)
    {
        return;
    }

    if ((id.x - (float)width/2.0) * (id.x - (float)width/2) + (id.y - (float)height/2) * (id.y - (float)height/2) <= (float)width * 5)
    {
        staticTrailMap[id.xy] = float4(0.5, 0.0, 0.0, 0);
    }
}

#pragma kernel StaticOverlay

bool staticOverlay;

// Overlays static trail map image on output.
[numthreads(8,8,1)]
void StaticOverlay (uint3 id : SV_DispatchThreadID)
{
    if (id.x < 0 || id.x >= (uint)width || id.y < 0 || id.y >= (uint)height)
    {
        return;
    }

    if (staticOverlay)
    {
        processedTrailMap[id.xy] += staticTrailMap[id.xy];
    }
}

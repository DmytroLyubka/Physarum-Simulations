#pragma kernel AlgorithmStep

// Agent structure to match that of the slime algorithm.
struct Agent {
    float2 position;
    float angle;
};

RWStructuredBuffer<Agent> agents; // contains agent structures
RWTexture2D<float4> trailMap; // tracks agent positions over time
uint agentCount; // number of agents in simulation
int width; // texture width
int height; // texture height
float moveSpeed; // agent move speed
float agentRotationAngle; // angle at which agents rotate
float sensorOffset; // sensor distance from agent
float sensorAngle; // sensor angle relative to agent
float time; // total time passed since start of simulation
int trailDeposit; // trail value agents deposit
bool agentCollision; // agent collision toggle
bool randomSteering;

// Computes a random 32-bit uint in the range 0 to 4294967295.
uint pcgHash(uint input)
{
    uint state = input * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

// Scales random uint to the range 0 and 1.
float scale(uint input)
{
    // 4294967295 = maximum value of a 32-bit unsigned int
    return input / 4294967295.0;
}


// Checks trail map value detected by a sensor with angle sensorDeltaAngle
// relative to agent.
float checkSensor(Agent agent, float sensorDeltaAngle)
{
    float globalSensorAngle = agent.angle + sensorDeltaAngle;
    float2 sensorDirection = float2(cos(globalSensorAngle), sin(globalSensorAngle));
    float2 sensorPosition = agent.position + sensorDirection * sensorOffset;

    int sensorCoordX = clamp(sensorPosition.x, 0, width-1);
    int sensorCoordY = clamp(sensorPosition.y, 0, height-1);

    // Return equally weighted sum of 4 channels. Maybe it makes more sense to
    // Take the sum of the first 3 (RGB) and multiply it by the alpha value?
    return dot(trailMap[int2(sensorCoordX, sensorCoordY)], int4(1, 1, 1, 1));
}

// Executes algorithm step.
[numthreads(16,1,1)]
void AlgorithmStep (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= agentCount)
    {
        return;
    }

    Agent agent = agents[id.x];
    float2 pos = agent.position;

    uint random = pcgHash(pos.y * width + pos.x + pcgHash(id.x + time * 100000));
    float randomSteerStrength = randomSteering ? 1 : scale(random);

    // Check sensor trail values
    float frontTrailValue = checkSensor(agent, 0);
    float leftTrailValue = checkSensor(agent, sensorAngle);
    float rightTrailValue = checkSensor(agent, -sensorAngle);

    // Continue in same direction
    if (frontTrailValue > leftTrailValue && frontTrailValue > rightTrailValue)
    {
        // pass
    }
    /* Note: It doesn't really make sense to have the choice between left and right
     * rotation be random here? The fact that the front sensor is detecting a weaker
     * chemoattractant than the two off-centre sensors does not imply that the left
     * and right sensors have equal chemoattractant concentration, it is very much
     * possible that the left sensor has detected a higher trail value while at the
     * same time the front sensor has detected the lowest trail value (in which case
     * the agent should rotate left).
     * 
     * TODO: Make this step more deterministic, only have rotation choice be random if
     * left and right sensors have the same trail value, both of which must be higher
     * than that of the front sensor.
     */
    else if (frontTrailValue < leftTrailValue && frontTrailValue < rightTrailValue)
    {
        if (randomSteerStrength > 0.5)
        {
            agents[id.x].angle += randomSteerStrength * agentRotationAngle;
        }
        else
        {
            agents[id.x].angle -= randomSteerStrength * agentRotationAngle;
        }
    }

    // Turn right
    else if (rightTrailValue > leftTrailValue)
    {
        agents[id.x].angle -= randomSteerStrength * agentRotationAngle;
    }
    // Turn left
    else if (leftTrailValue > rightTrailValue) 
    {
        agents[id.x].angle += randomSteerStrength * agentRotationAngle;
    }
    else
    {
        /* All sensor trail values are equal - maybe have random choice of rotation direction
            * here?
            */
        // pass
    }

    // Update position
    float2 direction = float2(cos(agent.angle), sin(agent.angle));
    float2 newPosition = agent.position + direction * moveSpeed;

    bool newPositionOccupied = false;
    // Check if new position is already occupied by an agent
    if (agentCollision)
    {
        for (uint i = 0; i < agentCount; i++)
        {
            if (all(agents[i].position == newPosition))
            {
                newPositionOccupied = true;
            }
        }
    }

    // Agent has hit boundary or target position is occupied, choose random agent angle and don't deposit trail
    if ((newPosition.x < 0 || newPosition.x >= width || newPosition.y < 0 || newPosition.y >= height)
            || newPositionOccupied) {
        random = pcgHash(random);
        float randomAngle = scale(random) * 2 * 3.1415;

        newPosition.x = clamp(newPosition.x, 0, width-1);
        newPosition.y = clamp(newPosition.y, 0, height-1);

        agents[id.x].angle = randomAngle;
    }
    // No boundaries hit, deposit trail
    else
    {
        trailMap[int2(newPosition)] += trailDeposit;
    }

    agents[id.x].position = newPosition;
}


#pragma kernel ProcessTrailMap

RWTexture2D<float4> processedTrailMap;
float decayRate;
float diffuseRate;
int kernelHalfWidth;

// Decays and diffuses trail map.
[numthreads(8,8,1)]
void ProcessTrailMap (uint3 id : SV_DispatchThreadID)
{
    if (id.x < 0 || id.x >= (uint)width || id.y < 0 || id.y >= (uint)height)
    {
        return;
    }

    float4 sum = 0;
    for (int x = -kernelHalfWidth; x <= kernelHalfWidth; x++)
    {
        for (int y = -kernelHalfWidth; y <= kernelHalfWidth; y++)
        {
            int kernelX = clamp(id.x + x, 0, width-1);
            int kernelY = clamp(id.y + y, 0, height-1);
            sum += trailMap[int2(kernelX, kernelY)];
        }
    }

    float4 diffusedTrail = sum / ((1 + 2 * kernelHalfWidth)*(1 + 2 * kernelHalfWidth));

    // Weighted average between original and diffused trail values
    float4 weightedDiffusedTrail = (1 - diffuseRate) * trailMap[id.xy] + diffuseRate * diffusedTrail;

    processedTrailMap[id.xy] = max(0, weightedDiffusedTrail - decayRate);
}
#pragma kernel AlgorithmStep

// Agent structure to match that of the slime algorithm.
struct Agent
{
    float2 position;
    float angle;
};

RWStructuredBuffer<Agent> agents; // contains agent structures
RWTexture2D<float4> trailMap; // tracks agent positions over time
RWTexture2D<float4> staticTrailMap; // tracks static trails
uint agentCount; // number of agents in simulation
int width; // texture width
int height; // texture height
float moveSpeed; // agent move speed
float agentRotationAngle; // angle at which agents rotate
float sensorOffset; // sensor distance from agent
float sensorAngle; // sensor angle relative to agent
float time; // total time passed since start of simulation
int trailDeposit; // trail value agents deposit
bool agentCollision; // agent collision toggle
bool torus; // torus surface toggle
bool staticTrails; // toggle static trails
float staticTrailStrength; // strength of static trails

// Computes a random 32-bit uint in the range 0 to 4294967295.
uint pcgHash(uint input)
{
    uint state = input * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

// Scales random uint to the range 0 and 1.
float scale(uint input)
{
    // 4294967295 = maximum value of a 32-bit unsigned int
    return input / 4294967295.0;
}

// Evaluates N mod M, supports negative N (native % operator does not)
float mod(float n, float m)
{
    return ((n % m) + m) % m;
}

// Clamps / wraps value on/around boundary depending on whether or not a torus surface is enabled.
float wrap(float value, float boundary)
{
    if (torus)
    {
        return (int) round(mod(value, boundary));
    }
    else
    {
        return clamp(value, 0, boundary-1);
    }
}

// Checks trail map value detected by a sensor with angle sensorDeltaAngle
// relative to agent.
float checkSensor(Agent agent, float sensorDeltaAngle)
{
    float globalSensorAngle = agent.angle + sensorDeltaAngle;
    float2 sensorDirection = float2(cos(globalSensorAngle), sin(globalSensorAngle));
    float2 sensorPosition = agent.position + sensorDirection * sensorOffset;

    int sensorCoordX = wrap(sensorPosition.x, width);
    int sensorCoordY = wrap(sensorPosition.y, height);

    // Return equally weighted sum of RGB channels for sensor's pixel in both the dynamic and static trail maps
    if (staticTrails)
    {
        // Static map formula: (alpha * 2) - 1, where alpha = 0 or 1
        return dot(trailMap[int2(sensorCoordX, sensorCoordY)].xyz, int3(1, 1, 1)) 
            + dot(staticTrailMap[int2(sensorCoordX, sensorCoordY)].xyz, int3(1, 1, 1)) * staticTrailStrength * ((staticTrailMap[int2(sensorCoordX, sensorCoordY)].w * 2) - 1);
    }
    else
    {
        return dot(trailMap[int2(sensorCoordX, sensorCoordY)].xyz, int3(1, 1, 1));
    }
}

// Executes algorithm step.
[numthreads(16,1,1)]
void AlgorithmStep (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= agentCount)
    {
        return;
    }

    Agent agent = agents[id.x];
    float2 pos = agent.position;

    uint random = pcgHash(pos.y * width + pos.x + pcgHash(id.x + time * 100000));

    // Check sensor trail values
    float frontTrailValue = checkSensor(agent, 0);
    float leftTrailValue = checkSensor(agent, sensorAngle);
    float rightTrailValue = checkSensor(agent, -sensorAngle);

    // All trail values are positive (no repellents found), algorithm step matches Jones's
    if (frontTrailValue >= 0 && leftTrailValue >= 0 && rightTrailValue >= 0)
    {
        // Continue in same direction
        if (frontTrailValue > leftTrailValue && frontTrailValue > rightTrailValue)
        {
            // pass
        }
        /* Note: It doesn't really make sense to have the choice between left and right
        * rotation be random here? The fact that the front sensor is detecting a weaker
        * chemoattractant than the two off-centre sensors does not imply that the left
        * and right sensors have equal chemoattractant concentration, it is very much
        * possible that the left sensor has detected a higher trail value while at the
        * same time the front sensor has detected the lowest trail value (in which case
        * the agent should rotate left).
        * 
        * TODO: Make this step more deterministic, only have rotation choice be random if
        * left and right sensors have the same trail value, both of which must be higher
        * than that of the front sensor.
        */
        else if (frontTrailValue < leftTrailValue && frontTrailValue < rightTrailValue)
        {
            if (scale(random) > 0.5)
            {
                agents[id.x].angle += agentRotationAngle;
            }
            else
            {
                agents[id.x].angle -= agentRotationAngle;
            }
        }

        // Turn right
        else if (rightTrailValue > leftTrailValue)
        {
            agents[id.x].angle -= agentRotationAngle;
        }
        // Turn left
        else if (leftTrailValue > rightTrailValue)
        {
            agents[id.x].angle += agentRotationAngle;
        }
        else
        {
            /* All sensor trail values are equal - maybe have random choice of rotation direction
                * here?
                */
            // pass
        }
    }
    // One of the sensors found a repellent: custom algorithm for deciding on rotation direction + magnitude.
    else
    {
        /* All trail values are negative, randomly rotate. We could maybe make this more deterministic
         * and rotate in the direction of the largest trail value?
         */
        if (leftTrailValue < 0 && frontTrailValue < 0 && rightTrailValue < 0)
        {
            if (scale(random) > 0.5)
            {
                agents[id.x].angle += agentRotationAngle;
            }
            else
            {
                agents[id.x].angle -= agentRotationAngle;
            }
        }
        // Left and front trail values are negative: rotate right twice as much.
        else if (leftTrailValue < 0 && frontTrailValue < 0)
        {
            agents[id.x].angle -= 2 * agentRotationAngle;
        }
        // Right and front trail values are negative: rotate left twice as much.
        else if (rightTrailValue < 0 && frontTrailValue < 0)
        {
            agents[id.x].angle += 2 * agentRotationAngle;
        }
        // Left and right trail values are negative: don't rotate.
        else if (leftTrailValue < 0 && rightTrailValue < 0)
        {
            // pass
        }
        // Left trail value is negative: rotate right once if front is largest, twice if right is largest.
        else if (leftTrailValue < 0)
        {
            if (frontTrailValue > rightTrailValue)
            {
                agents[id.x].angle -= agentRotationAngle;
            }
            else if (rightTrailValue > frontTrailValue)
            {
                agents[id.x].angle -= 2 * agentRotationAngle;
            }
            // Right and front trail values are equal: randomly rotate right once or twice.
            else
            {
                if (scale(random) > 0.5)
                {
                    agents[id.x].angle -= agentRotationAngle;
                }
                else
                {
                    agents[id.x].angle -= 2 * agentRotationAngle;
                }
            }
        }
        // Right trail value is negative: rotate left once if front is largest, twice if left is largest.
        else if (rightTrailValue < 0)
        {
            if (frontTrailValue > leftTrailValue)
            {
                agents[id.x].angle += agentRotationAngle;
            }
            else if (leftTrailValue > frontTrailValue)
            {
                agents[id.x].angle += 2 * agentRotationAngle;
            }
            // Left and front trail values are equal: randomly rotate left once or twice.
            else
            {
                if (scale(random) > 0.5)
                {
                    agents[id.x].angle += agentRotationAngle;
                }
                else
                {
                    agents[id.x].angle += 2 * agentRotationAngle;
                }
            }
        }
        // Front trail value is negative: rotate left twice if left is largest, right twice if right is largest.
        else if (frontTrailValue < 0)
        {
            if (leftTrailValue > rightTrailValue)
            {
                agents[id.x].angle += 2 * agentRotationAngle;
            }
            else
            {
                agents[id.x].angle -= 2 * agentRotationAngle;
            }
        }
    }

    // Update position
    float2 direction = float2(cos(agent.angle), sin(agent.angle));
    float2 newPosition = agent.position + direction * moveSpeed;

    if (torus)
    {
        newPosition.x = mod(newPosition.x, width);
        newPosition.y = mod(newPosition.y, height);
    }

    bool newPositionOccupied = false;
    // Check if new position is already occupied by an agent
    if (agentCollision)
    {
        for (uint i = 0; i < agentCount; i++)
        {
            if (all(agents[i].position == newPosition))
            {
                newPositionOccupied = true;
            }
        }
    }

    // Agent has hit boundary or target position is occupied, choose random agent angle and don't deposit trail
    if ((((newPosition.x < 0 || newPosition.x >= width || newPosition.y < 0 || newPosition.y >= height)) && !torus)
            || newPositionOccupied)
    {
        random = pcgHash(random);
        float randomAngle = scale(random) * 2 * 3.1415;

        newPosition.x = clamp(newPosition.x, 0, width-1);
        newPosition.y = clamp(newPosition.y, 0, height-1);

        agents[id.x].angle = randomAngle;
    }
    // No boundaries hit, deposit trail
    else
    {
        trailMap[int2(newPosition)] = float4(trailMap[int2(newPosition)].xyz + trailDeposit, trailMap[int2(newPosition)].w);
    }

    agents[id.x].position = newPosition;
}


#pragma kernel ProcessTrailMap

RWTexture2D<float4> processedTrailMap; // texture for trail map post-processing
float decayRate;
float diffuseRate;
int kernelHalfWidth;

// Decays and diffuses trail map.
[numthreads(8,8,1)]
void ProcessTrailMap (uint3 id : SV_DispatchThreadID)
{
    if (id.x < 0 || id.x >= (uint)width || id.y < 0 || id.y >= (uint)height)
    {
        return;
    }

    float3 sum = 0;
    for (int x = -kernelHalfWidth; x <= kernelHalfWidth; x++)
    {
        for (int y = -kernelHalfWidth; y <= kernelHalfWidth; y++)
        {
            int kernelX = wrap(id.x, width);
            int kernelY = wrap(id.y, height);
            sum += trailMap[int2(kernelX, kernelY)].xyz;
        }
    }

    float3 diffusedTrail = sum / ((1 + 2 * kernelHalfWidth)*(1 + 2 * kernelHalfWidth));

    // Weighted average between original and diffused trail values
    float3 weightedDiffusedTrail = (1 - diffuseRate) * trailMap[id.xy].xyz + diffuseRate * diffusedTrail;

    processedTrailMap[id.xy] = float4(max(0, weightedDiffusedTrail - decayRate), trailMap[id.xy].w);
}

#pragma kernel RefreshStaticValues

// Sets hardcoded static trail map values.
[numthreads(8,8,1)]
void RefreshStaticValues (uint3 id : SV_DispatchThreadID)
{
    if (id.x < 0 || id.x >= (uint)width || id.y < 0 || id.y >= (uint)height)
    {
        return;
    }

    // Circular attractant region at the centre of the texture
    if ((id.x - (float)width/2.0) * (id.x - (float)width/2) + (id.y - (float)height/2) * (id.y - (float)height/2) <= (float)width * 5)
    {
        // staticTrailMap[id.xy] = float4(0.5, 0.0, 0.0, 1.0);
    }
}

#pragma kernel StaticOverlay

// Overlays static trail map image onto output texture.
[numthreads(8,8,1)]
void StaticOverlay (uint3 id : SV_DispatchThreadID)
{
    if (id.x < 0 || id.x >= (uint)width || id.y < 0 || id.y >= (uint)height)
    {
        return;
    }

    processedTrailMap[id.xy] += staticTrailMap[id.xy];
}

#pragma kernel DrawStaticTrail

float mouseX; // mouse x-coordinate
float mouseY; // mouse y-coordinate
int brushType; // 0: attractant, 1: repellent, 2: eraser
int brushHalfWidth; // half-width of brush tooltip

// Draw attractant on trail map.
[numthreads(1,1,1)]
void DrawStaticTrail (uint3 id : SV_DispatchThreadID)
{
    float4 color;
    if (brushType == 0) // attractant
    {
        color = float4(0.5, 0.0, 0.0, 1.0);
    }
    else if (brushType == 1) // repellent
    {
        color = float4(0.0, 0.0, 0.5, 0.0);
    }
    else if (brushType == 2) // eraser
    {
        color = float4(0.0, 0.0, 0.0, 0.0);
    }

    for (int x = -brushHalfWidth; x <= brushHalfWidth; x++)
    {
        for (int y = -brushHalfWidth; y <= brushHalfWidth; y++)
        {
            int kernelX = wrap(mouseX + x, width);
            int kernelY = wrap(mouseY + y, height);
            staticTrailMap[int2(kernelX, kernelY)] = color;
        }
    }
}
#pragma kernel AlgorithmStep

// Agent structure to match that of the slime algorithm.
struct Agent {
    float2 position;
    float angle;
};

RWStructuredBuffer<Agent> agents; // contains agent structures
RWTexture2D<float4> trailMap; // tracks agent positions over time
uint agentCount; // number of agents in simulation
int width; // texture width
int height; // texture height
float deltaTime; // number of seconds each frame is visible for
float moveSpeed; // agent move speed
float agentRotationAngle; // angle at which agents rotate
float sensorOffset; // sensor distance from agent
float sensorAngle; // sensor angle relative to agent

// Hash function without Sine: https://www.shadertoy.com/view/4djSRW
// Provides a pseudorandom method to generate numbers.
float hash(float3 p)
{
    p = frac(p * 0.1031);
    p += dot(p, p.zyx + 31.32);
    return frac((p.x + p.y) * p.z);
}

// Evaluates N mod M, supports negative N (native % operator does not)
float mod(float n, float m)
{
    return ((n % m) + m) % m;
}

// Checks trail map value detected by a sensor with angle sensorDeltaAngle
// relative to agent.
float checkSensor(Agent agent, float sensorDeltaAngle)
{
    float globalSensorAngle = agent.angle + sensorDeltaAngle;
    float2 sensorDirection = float2(cos(globalSensorAngle), sin(globalSensorAngle));
    float2 sensorPosition = agent.position + sensorDirection * sensorOffset;

    int senseX = (int) round(mod(sensorPosition.x, width));
    int senseY = (int) round(mod(sensorPosition.y, height));

    // Return equally weighted sum of 4 channels. Maybe it makes more sense to
    // Take the sum of the first 3 (RGB) and multiply it by the alpha value?
    return dot(trailMap[int2(senseX, senseY)], int4(1, 1, 1, 1));
}


// Executes algorithm step.
[numthreads(16,1,1)]
void AlgorithmStep (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= agentCount) {
        return;
    }

    Agent agent = agents[id.x];
    float2 direction = float2(cos(agent.angle), sin(agent.angle));
    float2 newPosition = agent.position + direction * moveSpeed * deltaTime;

    // Move agent
    newPosition.x = mod(newPosition.x, width);
    newPosition.y = mod(newPosition.y, height);

    // Check sensor trail values
    float frontTrailValue = checkSensor(agent, 0);
    float leftTrailValue = checkSensor(agent, sensorAngle);
    float rightTrailValue = checkSensor(agent, -sensorAngle);

    if (frontTrailValue > leftTrailValue && frontTrailValue > rightTrailValue)
    {
        // pass
    }
    /* Note: It doesn't really make sense to have this step be random? The fact that
        * the front sensor is detecting a weaker chemoattractant than the two off-centre
        * sensors does not imply that the left and right sensors have equal "weight",
        * it is very much possible that the left sensor has detected a higher trail value
        * while at the same time the front sensor has detected the lowest trail value (in
        * which case the agent should rotate left).
        * 
        * TODO: Make this step more deterministic, only have random rotation if left and right
        * sensors have the same trail value, both of which must be higher than the front sensor's.
        */
    else if (frontTrailValue > leftTrailValue && frontTrailValue > rightTrailValue)
    {
        float randomValue = hash(float3(agent.position.x, agent.position.y, direction.x + direction.y));
        if (randomValue > 0.5)
        {
            agents[id.x].angle += agentRotationAngle;
        }
        else
        {
            agents[id.x].angle -= agentRotationAngle;
        }
    }
    else if (rightTrailValue < leftTrailValue)
    {
        agents[id.x].angle += agentRotationAngle;
    }
    else if (leftTrailValue > rightTrailValue)
    {
        agents[id.x].angle -= agentRotationAngle;
    }
    else
    {
        // all sensor trail values are equal
        // pass
    }

    // Set new position and update trail map
    agents[id.x].position = newPosition;
    trailMap[int2(newPosition.x, newPosition.y)] = float4(1, 1, 1, 1);
}


#pragma kernel ProcessTrailMap

RWTexture2D<float4> processedTrailMap;
float decaySpeed;

// Decays all trail map values by a constant.
[numthreads(8,8,1)]
void ProcessTrailMap (uint3 id : SV_DispatchThreadID)
{
    if (id.x < 0 || id.x >= (uint)width || id.y < 0 || id.y >= (uint)height)
    {
		return;
	}
    processedTrailMap[id.xy] = max(0, trailMap[id.xy] - decaySpeed * deltaTime);
}
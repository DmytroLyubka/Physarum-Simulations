#pragma kernel AlgorithmStep

// Agent structure to match that of the slime algorithm.
struct Agent {
    float2 position;
    float angle;
};

RWStructuredBuffer<Agent> agents; // contains agent structures
RWTexture2D<float4> trailMap; // tracks agent positions over time
uint agentCount; // number of agents in simulation
int width; // texture width
int height; // texture height
float deltaTime; // number of seconds each frame is visible for
float moveSpeed; // agent move speed
float agentRotationAngle; // angle at which agents rotate
float sensorOffset; // sensor distance from agent
float sensorAngle; // sensor angle relative to agent
float time; // total time passed since start of simulation
int trailDeposit; // trail value agents deposit
bool agentCollision; // agent collision toggle

// Hash function www.cs.ubc.ca/~rbridson/docs/schechter-sca08-turbulence.pdf
// Credits: SebLague
uint hash(uint state)
{
    state ^= 2747636419u;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    return state;
}

// Scales hash function output to be in the range 0-1
// Credits: SebLague
float scaleToRange01(uint state)
{
    return state / 4294967295.0;
}

// Checks trail map value detected by a sensor with angle sensorDeltaAngle
// relative to agent.
float checkSensor(Agent agent, float sensorDeltaAngle)
{
    float globalSensorAngle = agent.angle + sensorDeltaAngle;
    float2 sensorDirection = float2(cos(globalSensorAngle), sin(globalSensorAngle));
    float2 sensorPosition = agent.position + sensorDirection * sensorOffset;

    int sensorCoordX = clamp(sensorPosition.x, 0, width-1);
    int sensorCoordY = clamp(sensorPosition.y, 0, height-1);

    // Return equally weighted sum of 4 channels. Maybe it makes more sense to
    // Take the sum of the first 3 (RGB) and multiply it by the alpha value?
    return dot(trailMap[int2(sensorCoordX, sensorCoordY)], int4(1, 1, 1, 1));
}

// Executes algorithm step.
[numthreads(16,1,1)]
void AlgorithmStep (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= agentCount) {
		return;
	}

	Agent agent = agents[id.x];
	float2 pos = agent.position;

	uint random = hash(pos.y * width + pos.x + hash(id.x + time * 100000));
	float randomSteerStrength = scaleToRange01(random);

    // Check sensor trail values
	float sensorAngleRad = sensorAngle * (3.1415 / 180); // convert input angle to radians
    float frontTrailValue = checkSensor(agent, 0);
    float leftTrailValue = checkSensor(agent, sensorAngleRad);
    float rightTrailValue = checkSensor(agent, -sensorAngleRad);
	float turnSpeed = agentRotationAngle;

	// Continue in same direction
	if (frontTrailValue > leftTrailValue && frontTrailValue > rightTrailValue) {
		// pass
	}
    /* Note: It doesn't really make sense to have the choice between left and right
     * rotation be random here? The fact that the front sensor is detecting a weaker
     * chemoattractant than the two off-centre sensors does not imply that the left
     * and right sensors have equal chemoattractant concentration, it is very much
     * possible that the left sensor has detected a higher trail value while at the
     * same time the front sensor has detected the lowest trail value (in which case
     * the agent should rotate left).
     * 
     * TODO: Make this step more deterministic, only have rotation choice be random if
     * left and right sensors have the same trail value, both of which must be higher
     * than that of the front sensor.
     */
	else if (frontTrailValue < leftTrailValue && frontTrailValue < rightTrailValue) {
		if (randomSteerStrength > 0.5)
        {
            agents[id.x].angle += randomSteerStrength * turnSpeed * deltaTime;
        }
        else
        {
            agents[id.x].angle -= randomSteerStrength * turnSpeed * deltaTime;
        }
	}

	// Turn right
	else if (rightTrailValue > leftTrailValue) {
		agents[id.x].angle -= randomSteerStrength * turnSpeed * deltaTime;
	}
	// Turn left
	else if (leftTrailValue > rightTrailValue) {
		agents[id.x].angle += randomSteerStrength * turnSpeed * deltaTime;
	}
    else
    {
        /* All sensor trail values are equal - maybe have random choice of rotation direction
         * here?
         */
        // pass
    }

	// Update position
	float2 direction = float2(cos(agent.angle), sin(agent.angle));
	float2 newPosition = agent.position + direction * deltaTime * moveSpeed;

    bool newPositionOccupied = false;
    // Check if new position is already occupied by an agent
    if (agentCollision)
    {
        for (uint i = 0; i < agentCount; i++)
        {
            if (all(agents[i].position == newPosition))
            {
                newPositionOccupied = true;
            }
        }
    }

	// Agent has hit boundary or target position is occupied, choose random agent angle and don't deposit trail
	if ((newPosition.x < 0 || newPosition.x >= width || newPosition.y < 0 || newPosition.y >= height)
            || newPositionOccupied) {
		random = hash(random);
		float randomAngle = scaleToRange01(random) * 2 * 3.1415;

        newPosition.x = clamp(newPosition.x, 0, width-1);
        newPosition.y = clamp(newPosition.y, 0, height-1);

		agents[id.x].angle = randomAngle;
	}
    // No boundaries hit, deposit trail
	else {
        trailMap[int2(newPosition)] += trailDeposit * deltaTime;
	}

	agents[id.x].position = newPosition;
}


#pragma kernel ProcessTrailMap

RWTexture2D<float4> processedTrailMap;
float decayRate;
float diffuseRate;
int kernelHalfWidth;

// Decays and diffuses trail map after agents have moved.
[numthreads(8,8,1)]
void ProcessTrailMap (uint3 id : SV_DispatchThreadID)
{
    if (id.x < 0 || id.x >= (uint)width || id.y < 0 || id.y >= (uint)height)
    {
		return;
	}

    float4 sum = 0;
    for (int x = -kernelHalfWidth; x <= kernelHalfWidth; x++)
    {
        for (int y = -kernelHalfWidth; y <= kernelHalfWidth; y++)
        {
            int kernelX = clamp(id.x + x, 0, width-1);
            int kernelY = clamp(id.y + y, 0, height-1);
            sum += trailMap[int2(kernelX, kernelY)];
        }
    }
    
    float4 diffusedTrail = sum / ((1 + 2 * kernelHalfWidth)*(1 + 2 * kernelHalfWidth));
    
    float fixedDiffuseRate = diffuseRate * deltaTime;

    // Weighted average between original and diffused trail values
    float4 weightedDiffusedTrail = (1 - fixedDiffuseRate) * trailMap[id.xy] + fixedDiffuseRate * diffusedTrail;
    
    processedTrailMap[id.xy] = max(0, weightedDiffusedTrail - decayRate * deltaTime);
}